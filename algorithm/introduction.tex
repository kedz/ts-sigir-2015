
Figure \ref{alg:temporal-summarization} outlines our general temporal
summarization algorithm.  At each hour, the system processes each document in
the batch. It first discards any documents below a predefined relevance
threshold (Section \ref{sec:filtering:documents}).  It then discards any
sentences from the remaining documents which are unlikely to carry content
(Section \ref{sec:filtering:sentences}).  Following this filtering process, the
system must decide which of the remaining sentences should be considered an
update.  We refer to this as salience prediction and describe a feature-based
model for predicting salience (Section \ref{subsec:Predict}).  Because a single
sub-event may produce several high-quality but redundant sentences within an hour, we employ a cluster-based method for selecting exemplars of high salience sub-events (Section \ref{sec:ap}).  Finally, we employ a final deduplication phase to ensure that we only select novel updates (Section \ref{sec:novelty}).

% \begin{figure}
% \centering 
\begin{algorithm}%[H]
 \KwData{\\$Query$ --- the set of event query words\\ 
        $SC$ --- the stream corpus\\

         
}
 ~\\
 Initialize empty list $\mathbf{U}$ of updates\\
 Initialize empty list $\boldsymbol{\Pref}^{(U)}$ of update preferences\\
 $\corpus \gets \operatorname{FilterDocuments}(Query, SC)$ (See \cref{sec:filtering:documents})\\
 \For{$i \gets 1,\ldots,t $}{

  Initialize empty lists $\SMat, \Pref$ \;
      

  \For{$\doc \in \corpus_{\hour_i}$}{
   \For{$\sent \in \operatorname{FilterSentences}(\doc, Query)$ (See \cref{sec:filtering:sentences})\\}{
     $\SMat.\operatorname{append}(\sent)$\;
     $\sigma \gets \operatorname{PredictSalience}(\sent)$ (See \cref{subsec:Predict})\\     
     $\Pref.\operatorname{append}(\sigma)$\;
     
   }        
  }
  %$\Sim \gets \operatorname{ComputeSimilarityMatrix}(X)$\;
  %$\operatorname{}$
  ~\\ 
  $\mathbf{U}_{h_i}, \Pref^{(U)}_{h_i} \gets \operatorname{SentenceSelection}
    (\SMat, \Pref)$ (See \cref{sec:ap})\\
  ~\\
  $\operatorname{Emit}(\mathbf{U}_{h_i})$ \\ 
  $\mathbf{U}\operatorname{.append}(\mathbf{U}_{h_i})$ \\
  $\mathbf{\Pref}^{(U)}\operatorname{.append}(\Pref^{(U)}_{h_i})$ \\
%gets \Updates_{cache} \cup \Updates_{\hour}$\;

 } 
 \caption{Temporal Summarization Algorithm}\label{alg:temporal-summarization}
\end{algorithm}
% \end{figure}
